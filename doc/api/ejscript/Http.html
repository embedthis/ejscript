<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
   <title>Class Http</title>

   <link rel="stylesheet" type="text/css" href="doc.css" />
</head>

<body>
<div class='body'>

<div class="content">

<a name='top'></a>
<h1 class='className'>Http</h1>
<div class='classBlock'>
<table class='classHead' summary='Http'>
   <tr><td><strong>Module</strong></td><td>ejs</td></tr>
   <tr><td><strong>Definition</strong></td><td> class Http</td></tr>
   <tr><td><strong>Inheritance</strong></td><td>Http <img src='images/inherit.gif' alt='inherit'/> <a href='Object.html'>Object</a><tr><td><strong>Specified</strong></td><td>ejscript-2.2</td></tr>
<tr><td><strong>Stability</strong></td><td>Evolving.</td></tr>
       </td></tr>
</table>

<p class='classBrief'>The Http object represents a Hypertext Transfer Protocol version 1.1 client connection.</p>

<p class='classDescription'>It is used to issue 
HTTP requests and capture responses. It supports the HTTP/1.1 standard including methods for GET, POST, 
PUT, DELETE, OPTIONS, and TRACE. It also supports Keep-Alive and SSL connections.</p>

</div>


<hr />
<a name='Properties'></a>
<h2 class='classSection'>Properties</h2>
<table class='itemTable' summary='properties'>
   <tr><th>Qualifiers</th><th>Property</th><th>Type</th><th width='95%'>Description</th></tr>
<a name='Accepted'></a>
   <tr><td nowrap align='center'> static const </td><td>Accepted</td><td><a href='Number.html'>Number</a></td><td>HTTP Accepted Status (202). </td></tr>
<a name='BadGateway'></a>
   <tr><td nowrap align='center'> static const </td><td>BadGateway</td><td><a href='Number.html'>Number</a></td><td>HTTP Bad Gateway Status (502). </td></tr>
<a name='BadMethod'></a>
   <tr><td nowrap align='center'> static const </td><td>BadMethod</td><td><a href='Number.html'>Number</a></td><td>HTTP Method Not Allowed Status (405). </td></tr>
<a name='BadRange'></a>
   <tr><td nowrap align='center'> static const </td><td>BadRange</td><td><a href='Number.html'>Number</a></td><td>HTTP Requested Range Not Satisfiable (416). </td></tr>
<a name='BadRequest'></a>
   <tr><td nowrap align='center'> static const </td><td>BadRequest</td><td><a href='Number.html'>Number</a></td><td>HTTP Bad Request Status(400). </td></tr>
<a name='Conflict'></a>
   <tr><td nowrap align='center'> static const </td><td>Conflict</td><td><a href='Number.html'>Number</a></td><td>HTTP Conflict Status (409). </td></tr>
<a name='Continue'></a>
   <tr><td nowrap align='center'> static const </td><td>Continue</td><td><a href='Number.html'>Number</a></td><td>HTTP Continue Status (100). </td></tr>
<a name='Created'></a>
   <tr><td nowrap align='center'> static const </td><td>Created</td><td><a href='Number.html'>Number</a></td><td>HTTP Created Status (201). </td></tr>
<a name='EntityTooLarge'></a>
   <tr><td nowrap align='center'> static const </td><td>EntityTooLarge</td><td><a href='Number.html'>Number</a></td><td>HTTP Request Entity Too Large Status (413). </td></tr>
<a name='Forbidden'></a>
   <tr><td nowrap align='center'> static const </td><td>Forbidden</td><td><a href='Number.html'>Number</a></td><td>HTTP Forbidden Status (403). </td></tr>
<a name='GatewayTimeout'></a>
   <tr><td nowrap align='center'> static const </td><td>GatewayTimeout</td><td><a href='Number.html'>Number</a></td><td>HTTP Gateway Timeout Status (504). </td></tr>
<a name='Gone'></a>
   <tr><td nowrap align='center'> static const </td><td>Gone</td><td><a href='Number.html'>Number</a></td><td>HTTP Gone Status (410). </td></tr>
<a name='LengthRequired'></a>
   <tr><td nowrap align='center'> static const </td><td>LengthRequired</td><td><a href='Number.html'>Number</a></td><td>HTTP Length Required Status (411). </td></tr>
<a name='MovedPermanently'></a>
   <tr><td nowrap align='center'> static const </td><td>MovedPermanently</td><td><a href='Number.html'>Number</a></td><td>HTTP Moved Permanently Status (301). </td></tr>
<a name='MovedTemporarily'></a>
   <tr><td nowrap align='center'> static const </td><td>MovedTemporarily</td><td><a href='Number.html'>Number</a></td><td>HTTP Found but Moved Temporily Status (302). </td></tr>
<a name='MultipleChoice'></a>
   <tr><td nowrap align='center'> static const </td><td>MultipleChoice</td><td><a href='Number.html'>Number</a></td><td>HTTP Multiple Choices Status (300). </td></tr>
<a name='NoContent'></a>
   <tr><td nowrap align='center'> static const </td><td>NoContent</td><td><a href='Number.html'>Number</a></td><td>HTTP No Content Status (204). </td></tr>
<a name='NotAcceptable'></a>
   <tr><td nowrap align='center'> static const </td><td>NotAcceptable</td><td><a href='Number.html'>Number</a></td><td>HTTP Not Acceptable Status (406). </td></tr>
<a name='NotAuthoritative'></a>
   <tr><td nowrap align='center'> static const </td><td>NotAuthoritative</td><td><a href='Number.html'>Number</a></td><td>HTTP Non-Authoritative Information Status (203). </td></tr>
<a name='NotFound'></a>
   <tr><td nowrap align='center'> static const </td><td>NotFound</td><td><a href='Number.html'>Number</a></td><td>HTTP Not Found Status (404). </td></tr>
<a name='NotImplemented'></a>
   <tr><td nowrap align='center'> static const </td><td>NotImplemented</td><td><a href='Number.html'>Number</a></td><td>HTTP Not Implemented Status (501). </td></tr>
<a name='NotModified'></a>
   <tr><td nowrap align='center'> static const </td><td>NotModified</td><td><a href='Number.html'>Number</a></td><td>HTTP Not Modified Status (304). </td></tr>
<a name='Ok'></a>
   <tr><td nowrap align='center'> static const </td><td>Ok</td><td><a href='Number.html'>Number</a></td><td>HTTP Success Status (200). </td></tr>
<a name='PartialContent'></a>
   <tr><td nowrap align='center'> static const </td><td>PartialContent</td><td><a href='Number.html'>Number</a></td><td>HTTP Partial Content Status (206). </td></tr>
<a name='PaymentRequired'></a>
   <tr><td nowrap align='center'> static const </td><td>PaymentRequired</td><td><a href='Number.html'>Number</a></td><td>HTTP Payment Required Status (402). </td></tr>
<a name='PrecondFailed'></a>
   <tr><td nowrap align='center'> static const </td><td>PrecondFailed</td><td><a href='Number.html'>Number</a></td><td>HTTP Precondition Failed Status (412). </td></tr>
<a name='ProxyAuthRequired'></a>
   <tr><td nowrap align='center'> static const </td><td>ProxyAuthRequired</td><td><a href='Number.html'>Number</a></td><td>HTTP ProxyAuthentication Required Status (407). </td></tr>
<a name='RequestTimeout'></a>
   <tr><td nowrap align='center'> static const </td><td>RequestTimeout</td><td><a href='Number.html'>Number</a></td><td>HTTP Request Timeout Status (408). </td></tr>
<a name='Reset'></a>
   <tr><td nowrap align='center'> static const </td><td>Reset</td><td><a href='Number.html'>Number</a></td><td>HTTP Reset Content Status (205). </td></tr>
<a name='SeeOther'></a>
   <tr><td nowrap align='center'> static const </td><td>SeeOther</td><td><a href='Number.html'>Number</a></td><td>HTTP See Other Status (303). </td></tr>
<a name='ServerError'></a>
   <tr><td nowrap align='center'> static const </td><td>ServerError</td><td><a href='Number.html'>Number</a></td><td>HTTP Server Error Status (500). </td></tr>
<a name='ServiceUnavailable'></a>
   <tr><td nowrap align='center'> static const </td><td>ServiceUnavailable</td><td><a href='Number.html'>Number</a></td><td>HTTP Service Unavailable Status (503). </td></tr>
<a name='Unauthorized'></a>
   <tr><td nowrap align='center'> static const </td><td>Unauthorized</td><td><a href='Number.html'>Number</a></td><td>HTTP Unauthorized Status (401). </td></tr>
<a name='UnsupportedMedia'></a>
   <tr><td nowrap align='center'> static const </td><td>UnsupportedMedia</td><td><a href='Number.html'>Number</a></td><td>HTTP Unsupported Media Type (415). </td></tr>
<a name='UriTooLong'></a>
   <tr><td nowrap align='center'> static const </td><td>UriTooLong</td><td><a href='Number.html'>Number</a></td><td>HTTP Request URI Too Long Status (414). </td></tr>
<a name='UseProxy'></a>
   <tr><td nowrap align='center'> static const </td><td>UseProxy</td><td><a href='Number.html'>Number</a></td><td>HTTP Use Proxy Status (305). </td></tr>
<a name='VersionNotSupported'></a>
   <tr><td nowrap align='center'> static const </td><td>VersionNotSupported</td><td><a href='Number.html'>Number</a></td><td>HTTP Http Version Not Supported Status (505). </td></tr>
<a name='async'></a>
   <tr><td nowrap align='center'> get set </td><td>async</td><td><a href='Boolean.html'>Boolean</a></td><td>The current async mode. Set to true if the stream is in async mode.</td></tr>
<a name='certificate'></a>
   <tr><td nowrap align='center'> get set </td><td>certificate</td><td><a href='Path.html'>Path</a></td><td>Filename of the file of certificates used to verify server certificates. </td></tr>
<a name='contentLength'></a>
   <tr><td nowrap align='center'> get </td><td>contentLength</td><td><a href='Number.html'>Number</a></td><td>Response content body length. Set to the length of the response body in bytes or -1 if no body or not known.
To set the request body Content-Length, use setHeader("Content-Length", Length).</td></tr>
<a name='contentType'></a>
   <tr><td nowrap align='center'> get </td><td>contentType</td><td><a href='String.html'>String</a></td><td>Response content type derrived from the response Http Content-Type header. To set the request body Content-Type, use setHeader("Content-Type", MimeType).</td></tr>
<a name='date'></a>
   <tr><td nowrap align='center'> get </td><td>date</td><td><a href='Date.html'>Date</a></td><td>When the response was generated. Response date derrived from the response Http Date header.</td></tr>
<a name='finalized'></a>
   <tr><td nowrap align='center'> get </td><td>finalized</td><td><a href='Boolean.html'>Boolean</a></td><td>Has the request output been finalized. </td></tr>
<a name='followRedirects'></a>
   <tr><td nowrap align='center'> get set </td><td>followRedirects</td><td><a href='Boolean.html'>Boolean</a></td><td>Control whether redirects should be automatically followed by this Http object. When true, a redirected
response will be followed and the redirected URL will be transparently re-fetched.  Default is false.</td></tr>
<a name='headers'></a>
   <tr><td nowrap align='center'> get </td><td>headers</td><td><a href='Object.html'>Object</a></td><td>Response headers. Use <a href='#header'>header()</a> to retrieve a single header value.
Set to an object filled with all the response headers. If multiple headers of the same key value are
defined, their contents will be catenated with a ", " separator as per the HTTP/1.1 specification.</td></tr>
<a name='isSecure'></a>
   <tr><td nowrap align='center'> get </td><td>isSecure</td><td><a href='Boolean.html'>Boolean</a></td><td>Is the connection is utilizing SSL. </td></tr>
<a name='lastModified'></a>
   <tr><td nowrap align='center'> get </td><td>lastModified</td><td><a href='Date.html'>Date</a></td><td>When the response content was last modified. Set to the the value of the response Http Last-Modified header.
Set to null if not known.</td></tr>
<a name='limits'></a>
   <tr><td nowrap align='center'> get </td><td>limits</td><td><a href='Object.html'>Object</a></td><td>Resource limits for requests. </td></tr>
<a name='method'></a>
   <tr><td nowrap align='center'> get set </td><td>method</td><td><a href='String.html'>String</a></td><td>Http request method for this Http object. Default is "GET". Typical methods are: GET, POST, HEAD, OPTIONS, 
PUT, DELETE and TRACE.</td></tr>
<a name='response'></a>
   <tr><td nowrap align='center'> get set </td><td>response</td><td><a href='String.html'>String</a></td><td>Response body content as a string. The first time this property is read, the response content will be read 
and buffered.  Don't use this property in async mode as it will block. Set to the response as a string of 
characters. If the response has no body content, the empty string will be returned.</td></tr>
<a name='sessionCookie'></a>
   <tr><td nowrap align='center'> get </td><td>sessionCookie</td><td><a href='String.html'>String</a></td><td>Get the ejs session cookie. This call extracts the ejs session cookie from the Http response headers.
Ejscript sessions are identified by a client cookie which when transmitted with subsequent requests will 
permit the server to locate the relevant session state store for the server-side application. 
Use: setCookie(cookie) to transmit the cookie on subsquent requests.
Will be a string or null if there is no session cookie defined.</td></tr>
<a name='status'></a>
   <tr><td nowrap align='center'> get </td><td>status</td><td><a href='Number.html'>Number</a></td><td>Http response status code from the Http response status line, e.g. 200. Set to null if unknown.
This command will block until the request completes.</td></tr>
<a name='statusMessage'></a>
   <tr><td nowrap align='center'> get </td><td>statusMessage</td><td><a href='String.html'>String</a></td><td>Descriptive status message for the Http response. This message may come from either the HTTP response status
line or from a local error message if the response fails to parse.</td></tr>
<a name='uri'></a>
   <tr><td nowrap align='center'> get set </td><td>uri</td><td><a href='Uri.html'>Uri</a></td><td>The current Uri for this Http object. The Uri is used for the request URL when making a <a href='#connect'>connect</a> call.</td></tr>
<a name='verify'></a>
   <tr><td nowrap align='center'> get set </td><td>verify</td><td><a href='Boolean.html'>Boolean</a></td><td>Verify peer certificates. </td></tr>
</table>

<p class='inheritedLink'><a href='Object.html#Properties'><i>Inherited Properties</i></a></p>

<hr />
<a name='ClassMethods'></a>
<h2 class='classSection'>Http Class Methods</h2>
<table class='apiIndex' summary='methods'>
   <tr><th>Qualifiers</th><th width='95%'>Method</th></tr>
   <p>(No own class methods defined)</p></table>

<p class='inheritedLink'><a href='Object.html#InstanceMethods'><i>Inherited Methods</i></a></p>

<hr />
<a name='InstanceMethods'></a>
<h2 class='classSection'>Http Instance Methods</h2>
<table class='apiIndex' summary='methods'>
   <tr><th>Qualifiers</th><th width='95%'>Method</th></tr>
   <tr class='apiDef'><td class='apiType'></td><td><a href='#Http'><b>Http</b></a>(uri: <a href='Uri.html'>Uri</a> = null)</tr><tr class='apiBrief'><td>&nbsp;</td><td>Create an Http object.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#close'><b>close</b></a>(): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Close the stream.This immediately closes any open network connection and resets the http object to be ready for another 
connection.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#connect'><b>connect</b></a>(method: <a href='String.html'>String</a>, uri: <a href='Uri.html'>Uri</a> = null, data: <a href='Array.html'>Array</a>): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Commence a HTTP request for the current method and uri.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#finalize'><b>finalize</b></a>(): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Signals the end of any write data and flushes any buffered write data to the server.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#flush'><b>flush</b></a>(dir: <a href='Number.html'>Number</a> = expression): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Flush the stream and underlying streams.Flush request data.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#form'><b>form</b></a>(uri: <a href='Uri.html'>Uri</a>, data: <a href='Object.html'>Object</a>): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Commence a POST request with www-url encoded key=value data.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#get'><b>get</b></a>(uri: <a href='Uri.html'>Uri</a> = null, data: <a href='Array.html'>Array</a>): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Commence a GET request for the current uri.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#getRequestHeaders'><b>getRequestHeaders</b></a>(): <a href='Object.html'>Object</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Get the (proposed) request headers that will be sent with the request.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#head'><b>head</b></a>(uri: <a href='Uri.html'>Uri</a> = null): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Commence a HEAD request for the current uri.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#header'><b>header</b></a>(key: <a href='String.html'>String</a>): <a href='String.html'>String</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Get the value of a single response header.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#off'><b>off</b></a>(name, observer: <a href='Function.html'>Function</a>): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Remove an observer from the stream.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#on'><b>on</b></a>(name, observer: <a href='Function.html'>Function</a>): <a href='Http.html'>Http</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Add an observer to the stream for the named events.All events are called with the following signature.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#post'><b>post</b></a>(uri: <a href='Uri.html'>Uri</a>, data: <a href='Array.html'>Array</a>): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Initiate a POST request.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#put'><b>put</b></a>(uri: <a href='Uri.html'>Uri</a>, data: <a href='Array.html'>Array</a>): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Commence a PUT request for the current uri.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#read'><b>read</b></a>(buffer: <a href='ByteArray.html'>ByteArray</a>, offset: <a href='Number.html'>Number</a>, count: <a href='Number.html'>Number</a> = -1): <a href='Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read a data from the stream.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#readLines'><b>readLines</b></a>(count: <a href='Number.html'>Number</a> = -1): <a href='Array.html'>Array</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read the request response as an array of lines.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#readString'><b>readString</b></a>(count: <a href='Number.html'>Number</a> = -1): <a href='String.html'>String</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read the response as a string.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#readXml'><b>readXml</b></a>(): <a href='XML.html'>XML</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read the request response as an XML document.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#reset'><b>reset</b></a>(): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Reset the Http object to prepare for a new request.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#setCookie'><b>setCookie</b></a>(cookie: <a href='String.html'>String</a>): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Set a "Cookie" header in the request headers.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#setCredentials'><b>setCredentials</b></a>(username: <a href='String.html'>String</a>, password: <a href='String.html'>String</a>, type: <a href='String.html'>String</a> = null): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Set the user credentials to use if the request requires authentication.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#setHeader'><b>setHeader</b></a>(key: <a href='String.html'>String</a>, value: <a href='String.html'>String</a>, overwrite: <a href='Boolean.html'>Boolean</a> = true): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Set a request header.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#setHeaders'><b>setHeaders</b></a>(headers: <a href='Object.html'>Object</a>, overwrite: <a href='Boolean.html'>Boolean</a> = true): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Set request headers.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#setLimits'><b>setLimits</b></a>(limits: <a href='Object.html'>Object</a>): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Update the request resource limits.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#trace'><b>trace</b></a>(options: <a href='Object.html'>Object</a>): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Configure request tracing for the request.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#upload'><b>upload</b></a>(uri: <a href='String.html'>String</a>, files: <a href='Object.html'>Object</a>, fields: <a href='Object.html'>Object</a> = null): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Upload files using multipart/mime.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#wait'><b>wait</b></a>(timeout: <a href='Number.html'>Number</a> = -1): <a href='Boolean.html'>Boolean</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Wait for a request to complete.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#write'><b>write</b></a>(data: <a href='Array.html'>Array</a>): <a href='Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Write data to the stream.Write body data to the server.</td></tr>
</table>

<p class='inheritedLink'><a href='Object.html#InstanceMethods'><i>Inherited Methods</i></a></p>

<hr />
<h2>Method Detail</h2>
<a name='Http'></a>
<div class='api'>
<div class='apiSig'>    Http(uri: <a href='Uri.html'>Uri</a> = null)
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Create an Http object. The object is initialized with the Uri.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>uri: <a href='Uri.html'>Uri</a> </td><td>The (optional) Uri to initialize with. [default: null]</td></tr></table></dd>
</dl><dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if the Uri is malformed.
</dd>
</dl></div>
</div>
<hr />
<a name='close'></a>
<div class='api'>
<div class='apiSig'>    close(): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Close the stream.This immediately closes any open network connection and resets the http object to be ready for another 
connection. Connections should be explicitly closed rather than relying on the garbage collector to 
dispose of the Http object and automatically close the connection. If you have more requests that can 
be issued on the same network connection, use reset() rather than close to prepare for a new request 
on the same connection.</dd></dl>
<dl><dt>Events</dt>
<dd><table class='parameters' summary ='events'>
<td class='param'>close</td><td>A close event is issued before closing the stream.</td></tr>
</table></dd>
</dl></div>
</div>
<hr />
<a name='connect'></a>
<div class='api'>
<div class='apiSig'>    connect(method: <a href='String.html'>String</a>, uri: <a href='Uri.html'>Uri</a> = null, data: <a href='Array.html'>Array</a>): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Commence a HTTP request for the current method and uri. The HTTP method should be defined via the <a href='#method'>method</a> 
property and Uri via the <a href='#uri'>uri</a> property. This routine is typically not used. Rather it is invoked via one 
of the Http methods <a href='#get'>get()</a> <a href='#head'>head()</a> <a href='#post'>post()</a> instead. This call, and the Http method calls  may not immediately
initiate the connection. The Http class will delay connections until <a href='#finalize'>finalize()</a> is called explicitly or 
implicitly reading <a href='#status'>status</a> or response content. This enables the request content length to be determined 
automatically for smaller requests where the request body data can be buffered and measured before sending 
the request headers.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>method: <a href='String.html'>String</a> </td><td>Http method. This is typically "GET" or "POST".</td></tr><tr class='param'><td class='param'>uri: <a href='Uri.html'>Uri</a> </td><td>New uri to use. This overrides any previously defined uri for the Http object. [default: null]</td></tr><tr class='param'><td class='param'>data: <a href='Array.html'>Array</a> </td><td>Data objects to send with the request. Data is written raw and is not encoded or converted.  However, the routine intelligently handles arrays such that, each element of the array will be written.</td></tr></table></dd>
</dl><dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if the request cannot be issued to the remote server. Once the connection has been made,  exceptions will not be thrown and $status must be consulted for request status.
</dd>
</dl></div>
</div>
<hr />
<a name='finalize'></a>
<div class='api'>
<div class='apiSig'>    finalize(): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Signals the end of any write data and flushes any buffered write data to the server. </dd></dl>
</div>
</div>
<hr />
<a name='flush'></a>
<div class='api'>
<div class='apiSig'>    flush(dir: <a href='Number.html'>Number</a> = expression): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Flush the stream and underlying streams.Flush request data. A supplied flush <a href='#direction'>direction</a> argument modifies the effect of this call.
If direction is set to Stream.READ, then all read data is discarded. If direction is set to Stream.WRITE, 
any buffered data is written. Stream.BOTH will cause both directions to be flushed. If the stream is in 
sync mode, this call will block until all data is written. If the stream is in async mode, it will attempt 
to write all data but will return immediately. Defaults to Stream.WRITE.Flush will force buffered request data to be sent immediately to the server.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>dir: <a href='Number.html'>Number</a> </td><td>Direction to flush. Set to <a href='#READ'>READ</a> <a href='#WRITE'>WRITE</a> or <a href='#BOTH'>BOTH</a>. [default: expression]</td></tr></table></dd>
</dl></div>
</div>
<hr />
<a name='form'></a>
<div class='api'>
<div class='apiSig'>    form(uri: <a href='Uri.html'>Uri</a>, data: <a href='Object.html'>Object</a>): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Commence a POST request with www-url encoded key=value data. See <a href='#connect'>connect()</a> for connection details.
This will encode each data objects as a string of "key=value" pairs separated by "&" characters.
After writing data, <a href='#form'>form()</a> will call <a href='#finalize'>finalize()</a>. </dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>uri: <a href='Uri.html'>Uri</a> </td><td>Optional request uri. If non-null, this overrides any previously defined uri for the Http object. If null, use a previously defined uri.</td></tr><tr class='param'><td class='param'>data: <a href='Object.html'>Object</a> </td><td>Optional object hash of key value pairs to use as the post data. These are www-url-encoded and the content mime type is set to "application/x-www-form-urlencoded".</td></tr></table></dd>
</dl><dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if the request cannot be issued to the remote server.
</dd>
</dl></div>
</div>
<hr />
<a name='get'></a>
<div class='api'>
<div class='apiSig'>    get(uri: <a href='Uri.html'>Uri</a> = null, data: <a href='Array.html'>Array</a>): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Commence a GET request for the current uri. See <a href='#connect'>connect()</a> for connection details.
This call initiates a GET request. It does not wait for the request to complete. 
The <a href='#get'>get()</a> method will call finalize. If you need to send body content with a get request, use connect(). 
Once initiated, one of the <a href='#read'>read</a> or response routines  may be used to receive the response data.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>uri: <a href='Uri.html'>Uri</a> </td><td>The uri to get. This overrides any previously defined uri for the Http object. If null, use a previously defined uri. [default: null]</td></tr><tr class='param'><td class='param'>data: <a href='Array.html'>Array</a> </td><td>Data objects to send with the request. Data is written raw and is not encoded or converted.  However, the routine intelligently handles arrays such that, each element of the array will be written.</td></tr></table></dd>
</dl><dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if the request cannot be issued to the remote server. Once the connection has been made,  exceptions will not be thrown and $status must be consulted for request status.
</dd>
</dl></div>
</div>
<hr />
<a name='getRequestHeaders'></a>
<div class='api'>
<div class='apiSig'>    getRequestHeaders(): <a href='Object.html'>Object</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Get the (proposed) request headers that will be sent with the request. Use <a href='#headers'>headers</a> to get the response
headers or header(key) to get a single response header.</dd></dl>
<dl><dt>Returns</dt>
<dd>The set of request headers that will be used when the request is sent.</dd></dl>
</div>
</div>
<hr />
<a name='head'></a>
<div class='api'>
<div class='apiSig'>    head(uri: <a href='Uri.html'>Uri</a> = null): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Commence a HEAD request for the current uri. See <a href='#connect'>connect()</a> for connection details.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>uri: <a href='Uri.html'>Uri</a> </td><td>The request uri. This overrides any previously defined uri for the Http object. If null, use a previously defined uri. [default: null]</td></tr></table></dd>
</dl><dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if the request cannot be issued to the remote server.
</dd>
</dl></div>
</div>
<hr />
<a name='header'></a>
<div class='api'>
<div class='apiSig'>    header(key: <a href='String.html'>String</a>): <a href='String.html'>String</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Get the value of a single response header. This is a higher performance API than using response.headers["key"].</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>key: <a href='String.html'>String</a> </td><td>Header key value to lookup. The lookup is caseless, i.e. the key can be any case of mix of case.</td></tr></table></dd>
</dl><dl><dt>Returns</dt>
<dd>The header field value as a string or null if not known.</dd></dl>
</div>
</div>
<hr />
<a name='off'></a>
<div class='api'>
<div class='apiSig'>    off(name, observer: <a href='Function.html'>Function</a>): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Remove an observer from the stream. </dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>name </td><td>Event name previously used with observe. The name may be an array of events.</td></tr><tr class='param'><td class='param'>observer: <a href='Function.html'>Function</a> </td><td>Observer function previously used with observe.</td></tr></table></dd>
</dl></div>
</div>
<hr />
<a name='on'></a>
<div class='api'>
<div class='apiSig'>    on(name, observer: <a href='Function.html'>Function</a>): <a href='Http.html'>Http</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Add an observer to the stream for the named events.All events are called with the following signature. The "this" object will be set to the instance object
if the callback is a method. Otherwise, "this" will be set to the Http instance. If Function.bind may also
be used to define the "this" object and to inject additional callback arguments. 
function (event: String, http: Http): Void.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>name: [String|Array]</td><td>Name of the event to listen for. The name may be an array of events.</td></tr><tr class='param'><td class='param'>observer: <a href='Function.html'>Function</a> </td><td>Callback observer function. The function is called with the following signature: function observer(event: String, ...args): Void.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' summary ='events'>
<td class='param'>readable</td><td>Issued when the stream becomes readable.</td></tr>
<td class='param'>writable</td><td>Issued when the stream becomes writable.</td></tr>
<td class='param'>close</td><td>Issued when stream is being closed.</td></tr>
<td class='param'>headers</td><td>Issued when the response headers have been fully received.</td></tr>
<td class='param'>readable</td><td>Issued when some body content is available.</td></tr>
<td class='param'>writable</td><td>Issued when the connection is writable to accept body data (PUT, POST).</td></tr>
<td class='param'>complete</td><td>Issued when the request completes. Complete is always issued whether the request errors or not.</td></tr>
<td class='param'>error</td><td>Issued if the request does not complete successfully. This is not issued if the request  ompletes successfully but with a non 200 Http status code.</td></tr>
</table></dd>
</dl></div>
</div>
<hr />
<a name='post'></a>
<div class='api'>
<div class='apiSig'>    post(uri: <a href='Uri.html'>Uri</a>, data: <a href='Array.html'>Array</a>): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Initiate a POST request. This call initiates a POST request. It does not wait for the request to complete. 
Posted data is NOT URL encoded. If you want to post data to a form, consider using the <a href='#form'>form</a> method instead 
which automatically URL encodes the data. After writing data, <a href='#post'>post()</a> will call finalize(). Post data may be 
supplied may alternatively via <a href='#write'>write</a>. </dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>uri: <a href='Uri.html'>Uri</a> </td><td>Optional request uri. If non-null, this overrides any previously defined uri for the Http object.  If null, use a previously defined uri.</td></tr><tr class='param'><td class='param'>data: <a href='Array.html'>Array</a> </td><td>Data objects to send with the post request. Data is written raw and is not encoded or converted.</td></tr></table></dd>
</dl><dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if the request cannot be issued to the remote server.
</dd>
</dl></div>
</div>
<hr />
<a name='put'></a>
<div class='api'>
<div class='apiSig'>    put(uri: <a href='Uri.html'>Uri</a>, data: <a href='Array.html'>Array</a>): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Commence a PUT request for the current uri. See <a href='#connect'>connect()</a> for connection details.
If a contentLength has not been previously defined for this request, chunked transfer encoding will be enabled.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>uri: <a href='Uri.html'>Uri</a> </td><td>The uri to put. This overrides any previously defined uri for the Http object. If null, use a previously defined uri.</td></tr><tr class='param'><td class='param'>data: <a href='Array.html'>Array</a> </td><td>Optional data objects to write to the request stream. Data is written raw and is not encoded  or converted.  However, put intelligently handles arrays such that, each element of the array will be  written. If encoding of put data is required, use the BinaryStream filter. If no putData is supplied, and the ContentLength header is non-zero you must call <a href='#write'>write</a> to supply the body data.</td></tr><tr class='param'><td class='param'>data: <a href='Array.html'>Array</a> </td><td>Optional object hash of key value pairs to use as the post data.</td></tr></table></dd>
</dl><dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if the request cannot be issued to the remote server.
</dd>
</dl></div>
</div>
<hr />
<a name='read'></a>
<div class='api'>
<div class='apiSig'>    read(buffer: <a href='ByteArray.html'>ByteArray</a>, offset: <a href='Number.html'>Number</a>, count: <a href='Number.html'>Number</a> = -1): <a href='Number.html'>Number</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Read a data from the stream. If data is available, the call will return immediately. 
If no data is available and the stream is in sync mode, the call will block until data is available.
If no data is available and the stream is in async mode, the call will not block and will return immediately.
In this case a "readable" event will be issued when data is available for reading.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>buffer: <a href='ByteArray.html'>ByteArray</a> </td><td>Destination byte array for read data.</td></tr><tr class='param'><td class='param'>offset: <a href='Number.html'>Number</a> </td><td>Offset in the byte array to place the data. If the offset is -1, then data is appended to the buffer write <a href='#position'>position</a> which is then updated. If offset is >= 0, the data is read  to the offset and the read pointer is set to the offset and the write pointer to one past the end of  the data just read.</td></tr><tr class='param'><td class='param'>count: <a href='Number.html'>Number</a> </td><td>Read up to this number of bytes. If -1, read as much as the buffer will hold up. If the  stream is of fixed and known length (such as a file) and the buffer is of sufficient size or is growable,  read the entire stream. If the buffer is of a fixed size, ready only what will fit into the buffer. [default: -1]</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' summary ='events'>
<td class='param'>readable</td><td>Issued when there is new read data available.</td></tr>
<td class='param'>writable</td><td>Issued when the stream becomes empty.</td></tr>
</table></dd>
</dl><dl><dt>Returns</dt>
<dd>A count of the bytes actually read. Returns null on EOF or errors.</dd></dl>
</div>
</div>
<hr />
<a name='readLines'></a>
<div class='api'>
<div class='apiSig'>    readLines(count: <a href='Number.html'>Number</a> = -1): <a href='Array.html'>Array</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Read the request response as an array of lines. This call will block and should not be used in async mode.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>count: <a href='Number.html'>Number</a> </td><td>Of linese to read. Returns the entire response contents if count is -1. [default: -1]</td></tr></table></dd>
</dl><dl><dt>Returns</dt>
<dd>An array of strings.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if an I/O error occurs.
</dd>
</dl></div>
</div>
<hr />
<a name='readString'></a>
<div class='api'>
<div class='apiSig'>    readString(count: <a href='Number.html'>Number</a> = -1): <a href='String.html'>String</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Read the response as a string. This call will block and should not be used in async mode.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>count: <a href='Number.html'>Number</a> </td><td>Of bytes to read. Returns the entire response contents if count is -1. [default: -1]</td></tr></table></dd>
</dl><dl><dt>Returns</dt>
<dd>A string of <a href='#count'>count</a> characters beginning at the start of the response data.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if an I/O error occurs.
</dd>
</dl></div>
</div>
<hr />
<a name='readXml'></a>
<div class='api'>
<div class='apiSig'>    readXml(): <a href='XML.html'>XML</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Read the request response as an XML document. This call will block and should not be used in async mode.</dd></dl>
<dl><dt>Returns</dt>
<dd>The response content as an XML object.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if an I/O error occurs.
</dd>
</dl></div>
</div>
<hr />
<a name='reset'></a>
<div class='api'>
<div class='apiSig'>    reset(): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Reset the Http object to prepare for a new request. This will discard existing headers and security 
credentials. It will not close the connection to TCP/IP and thus Keep-Alive will be maintained.</dd></dl>
</div>
</div>
<hr />
<a name='setCookie'></a>
<div class='api'>
<div class='apiSig'>    setCookie(cookie: <a href='String.html'>String</a>): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Set a "Cookie" header in the request headers. This is used to send a cookie to the server.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>cookie: <a href='String.html'>String</a> </td><td>Cookie header value.</td></tr></table></dd>
</dl></div>
</div>
<hr />
<a name='setCredentials'></a>
<div class='api'>
<div class='apiSig'>    setCredentials(username: <a href='String.html'>String</a>, password: <a href='String.html'>String</a>, type: <a href='String.html'>String</a> = null): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Set the user credentials to use if the request requires authentication. </dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>username: <a href='String.html'>String</a> </td><td>String user name to use. If null, then reset the current credentials.</td></tr><tr class='param'><td class='param'>password: <a href='String.html'>String</a> </td><td>Un-encrypted string password to use. Set to null to reset the current credentials.</td></tr><tr class='param'><td class='param'>type: <a href='String.html'>String</a> </td><td>Authentication type. Set to basic or digest. Defaults to basic. If not set, then the authentication type is determined by the response from the server and the  request will be retried if it fails with an authentication error. [default: null]</td></tr></table></dd>
</dl></div>
</div>
<hr />
<a name='setHeader'></a>
<div class='api'>
<div class='apiSig'>    setHeader(key: <a href='String.html'>String</a>, value: <a href='String.html'>String</a>, overwrite: <a href='Boolean.html'>Boolean</a> = true): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Set a request header. Use setHeaders() to set all the headers. Use <a href='#getRequestHeaders'>getRequestHeaders()</a> to retrieve and examine
the request header set.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>key: <a href='String.html'>String</a> </td><td>The header keyword for the request, e.g. "accept".</td></tr><tr class='param'><td class='param'>value: <a href='String.html'>String</a> </td><td>The value to associate with the header, e.g. "yes".</td></tr><tr class='param'><td class='param'>overwrite: <a href='Boolean.html'>Boolean</a> </td><td>If the header is already defined and overwrite is true, then the new value will overwrite the old. If overwrite is false, the new value will be catenated to the old value with a ", " separator. [default: true]</td></tr></table></dd>
</dl></div>
</div>
<hr />
<a name='setHeaders'></a>
<div class='api'>
<div class='apiSig'>    setHeaders(headers: <a href='Object.html'>Object</a>, overwrite: <a href='Boolean.html'>Boolean</a> = true): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Set request headers. Use setHeader() to set a single header. Use <a href='#getRequestHeaders'>getRequestHeaders()</a> to retrieve and examine 
the request headers set.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>headers: <a href='Object.html'>Object</a> </td><td>Object hash of headers to set.</td></tr><tr class='param'><td class='param'>overwrite: <a href='Boolean.html'>Boolean</a> </td><td>If true, the new set of headers completely replaces the existing set of request headers. If overwrite is false, a new header value will be catenated to the old value after a ", " separator. [default: true]</td></tr></table></dd>
</dl></div>
</div>
<hr />
<a name='setLimits'></a>
<div class='api'>
<div class='apiSig'>    setLimits(limits: <a href='Object.html'>Object</a>): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Update the request resource limits. The supplied limit fields are updated.
See <a href='#limit'>limit</a> for limit field details.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>limits: <a href='Object.html'>Object</a> </td><td>Object hash of limit fields and values.</td></tr></table></dd>
</dl><dl><dt>See Also</dt>
<dd>
<a href='limits.html'>limits</a>
</dd></dl>
</div>
</div>
<hr />
<a name='trace'></a>
<div class='api'>
<div class='apiSig'>    trace(options: <a href='Object.html'>Object</a>): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Configure request tracing for the request. The default is to trace the first line of requests and responses at
level 2 and to trace headers at level 3. The options argument contains optional properties: rx and tx 
(for receive and transmit tracing). The rx and tx properties may contain an object hash which describes 
the tracing for that direction and includes any of the following fields:.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>options: <a href='Object.html'>Object</a> </td><td>Set of trace options with properties "rx" and "tx" for receive and transmit direction tracing. The include property is an array of file extensions to include in tracing. The include property is an array of file extensions to exclude from tracing. The all property specifies that everything for this direction should be traced. The conn property specifies that new connections should be traced. The first property specifies that the first line of the request should be traced. The headers property specifies that the headers (including first line) of the request should be traced. The body property specifies that the body content of the request should be traced. The size property specifies a maximum body size in bytes that will be traced. Content beyond this limit  will not be traced.</td></tr></table></dd>
</dl><dl><dt>Options</dt>
<dd><table class='parameters' summary ='options'>
<td class='param'>transmit.</td><td>Object hash with optional properties: include, exclude, first, headers, body, size.</td></tr>
<td class='param'>receive.</td><td>Object hash with optional properties: include, exclude, conn, first, headers, body, size.</td></tr>
</table></dd>
</dl><dl><dt>Example</dt>
<dd><pre>trace({
    transmit: { exclude: ["gif", "png"], "headers": 3, "body": 4, size: 1000000 }
    receive:  { "conn": 1, "headers": 2 , "body": 4, size: 1024 }
})</pre></dd></dl>
</div>
</div>
<hr />
<a name='upload'></a>
<div class='api'>
<div class='apiSig'>    upload(uri: <a href='String.html'>String</a>, files: <a href='Object.html'>Object</a>, fields: <a href='Object.html'>Object</a> = null): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Upload files using multipart/mime. This routine initiates a POST request and sends the specified files
and form fields using multipart mime encoding. This call is synchronous (blocks) until complete.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>uri: <a href='String.html'>String</a> </td><td>The uri to upload to. This overrides any previously defined uri for the Http object.</td></tr><tr class='param'><td class='param'>files: <a href='Object.html'>Object</a> </td><td>Object hash of files to upload.</td></tr><tr class='param'><td class='param'>fields: <a href='Object.html'>Object</a> </td><td>Object hash of of form fields to send. [default: null]</td></tr></table></dd>
</dl><dl><dt>Example</dt>
<dd><pre>fields = { name: "John Smith", address: "700 Park Avenue" }
files = { file1: "a.txt, file2: "b.txt" }
http.upload(URL, files, fields)</pre></dd></dl>
</div>
</div>
<hr />
<a name='wait'></a>
<div class='api'>
<div class='apiSig'>    wait(timeout: <a href='Number.html'>Number</a> = -1): <a href='Boolean.html'>Boolean</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Wait for a request to complete. This will call <a href='#finalize'>finalize()</a> if in sync mode and the request is not already 
finalized.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>timeout: <a href='Number.html'>Number</a> </td><td>Timeout in milliseconds to wait for the request to complete. A timeout of zero means don't block. A timeout of < 0 (default), means use the default request timeout. [default: -1]</td></tr></table></dd>
</dl><dl><dt>Returns</dt>
<dd>True if the request successfully completes.</dd></dl>
</div>
</div>
<hr />
<a name='write'></a>
<div class='api'>
<div class='apiSig'>    write(data: <a href='Array.html'>Array</a>): <a href='Number.html'>Number</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Write data to the stream.Write body data to the server. If the stream can accept all the write data, the call returns immediately with the number of bytes written. 
If writing more data than the stream can absorb in sync mode, the call will block until the data is written.
If writing more data than the stream can absorb in async mode, the call will not block and will buffer the
data and return immediately. Some streams will require a <a href='#flush'>flush()</a> call to actually send the data.
A "writable" event will be issued when the stream can again absorb more data.This will buffer the written data until either <a href='#flush'>flush()</a> or <a href='#finalize'>finalize()</a> is called. 
The Http "Content-Length" header should normally be set prior to writing any data for optimial data transfter.
If the Content-Length header has not been defined, the data will be transferred using chunked transfers.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' summary ='parameters'>
<tr class='param'><td class='param'>data: <a href='Array.html'>Array</a> </td><td>Data to write.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' summary ='events'>
<td class='param'>readable</td><td>Issued when data is written and a consumer can read without blocking.</td></tr>
<td class='param'>writable</td><td>Issued when the stream becomes empty and it is ready to be written to.</td></tr>
</table></dd>
</dl><dl><dt>Returns</dt>
<dd>A count of the bytes actually written.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if there is an I/O error.
</dd>
</dl></div>
</div>
<hr />
<div class="terms">
   <p class="terms">
       <a href="http://embedthis.com/">       Embedthis Software LLC, 2003-2012. All rights reserved. Embedthis is a trademark of Embedthis Software LLC.</a>
   </p>
</div></div>
</div>
</body>
</html>
