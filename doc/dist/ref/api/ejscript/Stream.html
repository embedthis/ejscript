<!DOCTYPE html>
<html>
<head>
   <title>Class Stream</title>

   <link rel="stylesheet" type="text/css" href="doc.css" />
</head>

<body>
<div class='body'>

<div class="content">

<a name='top'></a>
<h1 class='className'>Stream</h1>
<div class='classBlock'>
<table class='classHead' title='Stream'>
   <tr><td><strong>Module</strong></td><td>ejs</td></tr>
   <tr><td><strong>Definition</strong></td><td> class Stream</td></tr>
<tr><td><strong>Specified</strong></td><td>evolving</td></tr>
       </td></tr>
</table>

<p class='classBrief'>Stream objects represent streams of data that pass data elements between an endpoint known as a source or sink 
and a consumer or producer.</p>

<p class='classDescription'>Streams are full-duplex and may be stacked where intermediate streams are be used 
as filters or data mutators. Example endpoints are the File, Socket, and Http classes. The TextStream is an 
example of a filter stream. The data elements passed by streams may be any series of objects including: bytes, 
lines of text, numbers or objects. Streams may buffer the incoming data or not. Streams may issue events to 
registered observers for topics of interest. Streams may offer synchronous and asynchronous APIs.</p>

</div>


<hr />
<a name='Properties'></a>
<h2 class='classSection'>Properties</h2>
<table class='itemTable' title='properties'>
   <tr><th>Qualifiers</th><th>Property</th><th>Type</th><th width='95%'>Description</th></tr>
<a name='BOTH'></a>
   <tr><td nowrap align='center'> static const </td><td>BOTH</td><td>&nbsp;</td><td>Both directions constant for <a href='#flush'>flush()</a>.  </td></tr>
<a name='READ'></a>
   <tr><td nowrap align='center'> static const </td><td>READ</td><td>&nbsp;</td><td>Read direction constant for <a href='#flush'>flush()</a>.  </td></tr>
<a name='WRITE'></a>
   <tr><td nowrap align='center'> static const </td><td>WRITE</td><td>&nbsp;</td><td>Write direction constant for <a href='#flush'>flush()</a>.  </td></tr>
<a name='async'></a>
   <tr><td nowrap align='center'> get set </td><td>async</td><td><a href='Boolean.html'>Boolean</a></td><td>The current async mode. Set to true if the stream is in async mode.</td></tr>
</table>

<hr />
<a name='ClassMethods'></a>
<h2 class='classSection'>Stream Class Methods</h2>
<table class='apiIndex' title='methods'>
   <tr><th>Qualifiers</th><th width='95%'>Method</th></tr>
   <p>(No own class methods defined)</p></table>

<hr />
<a name='InstanceMethods'></a>
<h2 class='classSection'>Stream Instance Methods</h2>
<table class='apiIndex' title='methods'>
   <tr><th>Qualifiers</th><th width='95%'>Method</th></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#close'><b>close</b></a>(): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Close the stream.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#flush'><b>flush</b></a>(dir: <a href='Number.html'>Number</a> = BOTH): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Flush the stream and underlying streams.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#off'><b>off</b></a>(name, observer: <a href='Function.html'>Function</a>): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Remove an observer from the stream.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#on'><b>on</b></a>(name, observer: <a href='Function.html'>Function</a>): <a href='Stream.html'>Stream</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Add an observer to the stream for the named events.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#read'><b>read</b></a>(buffer: <a href='ByteArray.html'>ByteArray</a>, offset: <a href='Number.html'>Number</a> = 0, count: <a href='Number.html'>Number</a> = -1): <a href='Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read a data from the stream.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#write'><b>write</b></a>(data: <a href='Array.html'>Array</a>): <a href='Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Write data to the stream.</td></tr>
</table>

<hr />
<h2>Method Detail</h2>
<a name='close'></a>
<div class='api'>
<div class='apiSig'>    close(): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Close the stream. </dd></dl>
<dl><dt>Events</dt>
<dd><table class='parameters' title='events'>
<td class='param'>close</td><td>A close event is issued before closing the stream.</td></tr>
</table></dd>
</dl></div>
</div>
<hr />
<a name='flush'></a>
<div class='api'>
<div class='apiSig'>    flush(dir: <a href='Number.html'>Number</a> = BOTH): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Flush the stream and underlying streams. A supplied flush <a href='#direction'>direction</a> argument modifies the effect of this call.
If direction is set to Stream.READ, then all read data is discarded. If direction is set to Stream.WRITE, 
any buffered data is written. Stream.BOTH will cause both directions to be flushed. If the stream is in 
sync mode, this call will block until all data is written. If the stream is in async mode, it will attempt 
to write all data but will return immediately. Defaults to Stream.WRITE.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>dir: <a href='Number.html'>Number</a> </td><td>Direction to flush. Set to <a href='#READ'>READ</a> <a href='#WRITE'>WRITE</a> or <a href='#BOTH'>BOTH</a>. [default: BOTH]</td></tr></table></dd>
</dl></div>
</div>
<hr />
<a name='off'></a>
<div class='api'>
<div class='apiSig'>    off(name, observer: <a href='Function.html'>Function</a>): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Remove an observer from the stream. </dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>name </td><td>Event name previously used with observe. The name may be an array of events.</td></tr><tr class='param'><td class='param'>observer: <a href='Function.html'>Function</a> </td><td>Observer function previously used with observe.</td></tr></table></dd>
</dl></div>
</div>
<hr />
<a name='on'></a>
<div class='api'>
<div class='apiSig'>    on(name, observer: <a href='Function.html'>Function</a>): <a href='Stream.html'>Stream</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Add an observer to the stream for the named events. </dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>name: [String|Array]</td><td>Name of the event to listen for. The name may be an array of events.</td></tr><tr class='param'><td class='param'>observer: <a href='Function.html'>Function</a> </td><td>Callback observer function. The function is called with the following signature: function observer(event: String, ...args): Void.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' title='events'>
<td class='param'>readable</td><td>Issued when the stream becomes readable.</td></tr>
<td class='param'>writable</td><td>Issued when the stream becomes writable.</td></tr>
<td class='param'>close</td><td>Issued when stream is being closed. 8.</td></tr>
</table></dd>
</dl></div>
</div>
<hr />
<a name='read'></a>
<div class='api'>
<div class='apiSig'>    read(buffer: <a href='ByteArray.html'>ByteArray</a>, offset: <a href='Number.html'>Number</a> = 0, count: <a href='Number.html'>Number</a> = -1): <a href='Number.html'>Number</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Read a data from the stream. If data is available, the call will return immediately. 
If no data is available and the stream is in sync mode, the call will block until data is available.
If no data is available and the stream is in async mode, the call will not block and will return immediately.
In this case a "readable" event will be issued when data is available for reading.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>buffer: <a href='ByteArray.html'>ByteArray</a> </td><td>Destination byte array for read data.</td></tr><tr class='param'><td class='param'>offset: <a href='Number.html'>Number</a> </td><td>Offset in the byte array to place the data. If the offset is -1, then data is appended to the buffer write <a href='#position'>position</a> which is then updated. If offset is >= 0, the data is read  to the offset and the read pointer is set to the offset and the write pointer to one past the end of  the data just read. [default: 0]</td></tr><tr class='param'><td class='param'>count: <a href='Number.html'>Number</a> </td><td>Read up to this number of bytes. If -1, read as much as the buffer will hold up. If the  stream is of fixed and known length (such as a file) and the buffer is of sufficient size or is growable,  read the entire stream. If the buffer is of a fixed size, ready only what will fit into the buffer. [default: -1]</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' title='events'>
<td class='param'>readable</td><td>Issued when there is new read data available.</td></tr>
<td class='param'>writable</td><td>Issued when the stream becomes empty. `.</td></tr>
</table></dd>
</dl><dl><dt>Returns</dt>
<dd>A count of the bytes actually read. Returns null on EOF or errors.</dd></dl>
</div>
</div>
<hr />
<a name='write'></a>
<div class='api'>
<div class='apiSig'>    write(data: <a href='Array.html'>Array</a>): <a href='Number.html'>Number</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Write data to the stream. If the stream can accept all the write data, the call returns immediately with the number of bytes written. 
If writing more data than the stream can absorb in sync mode, the call will block until the data is written.
If writing more data than the stream can absorb in async mode, the call will not block and will buffer the
data and return immediately. Some streams will require a <a href='#flush'>flush()</a> call to actually send the data.
A "writable" event will be issued when the stream can again absorb more data.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>data: <a href='Array.html'>Array</a> </td><td>Data to write.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' title='events'>
<td class='param'>readable</td><td>Issued when data is written and a consumer can read without blocking.</td></tr>
<td class='param'>writable</td><td>Issued when the stream becomes empty and it is ready to be written to.</td></tr>
</table></dd>
</dl><dl><dt>Returns</dt>
<dd>A count of the bytes actually written.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if there is an I/O error.
</dd>
</dl></div>
</div>
<hr />
<div class="terms">
   <p class="terms">
       <a href="https://www.embedthis.com/">       Embedthis Software LLC, 2003-2014. All rights reserved. Embedthis is a trademark of Embedthis Software LLC.</a>
   </p>
</div></div>
</div>
</body>
</html>
