<!DOCTYPE html>
<html>
<head>
   <title>Class ByteArray</title>

   <link rel="stylesheet" type="text/css" href="doc.css" />
</head>

<body>
<div class='body'>

<div class="content">

<a name='top'></a>
<h1 class='className'>ByteArray</h1>
<div class='classBlock'>
<table class='classHead' title='ByteArray'>
   <tr><td><strong>Module</strong></td><td>ejs</td></tr>
   <tr><td><strong>Definition</strong></td><td>final  class ByteArray</td></tr>
   <tr><td><strong>Inheritance</strong></td><td>ByteArray <img src='images/inherit.gif' alt='inherit'/> <a href='Object.html'>Object</a><tr><td><strong>Specified</strong></td><td>ejscript-2.7</td></tr>
<tr><td><strong>Stability</strong></td><td>Evolving.</td></tr>
       </td></tr>
</table>

<p class='classBrief'>ByteArrays provide a resizable, integer indexed, in-memory store for bytes.</p>

<p class='classDescription'>ByteArrays can be used as a simple 
array type to store and encode data as bytes or they can be used as buffered loop-back Streams.<br/><br/>When used as a simple byte array, the ByteArray class offers a low level set of methods to insert and 
extract bytes. The index operator [] can be used to access individual bytes and the copyIn and copyOut methods 
can be used to get and put blocks of data. In this mode, the <a href='#readPosition'>readPosition</a> and <a href='#writePosition'>writePosition</a> properties are ignored.<br/><br/>Access to the byte array is from index zero up to the size defined by the <a href='#size'>size</a> property. When constructed, 
the ByteArray can be designated as resizable, in which case the initial size will grow as required to accomodate 
data and the <a href='#size'>size</a> property will be updated accordingly.<br/><br/>ByteArrays provide additional write methods to store data at the location specified by the <a href='#writePosition'>writePosition</a> 
property and read methods to read from the <a href='#readPosition'>readPosition</a> property. The <a href='#length'>length</a> property indicates how much 
data is available between the read and write position pointers. The <a href='#reset'>reset</a> method can reset the pointers to 
the start of the array.  When used with for/in, ByteArrays will iterate or enumerate over the available 
data between the read and write pointers.<br/><br/>If numeric values are read or written, they will be coded according to the value of the endian property 
which can be set to either LittleEndian or BigEndian.  If strings values are read or written, they will 
be encoded according to the value of the character set <a href='#encoding'>encoding</a> property.<br/><br/>When used as loop-back streams, data written to ByteArrays is immediately available for reading. 
ByteArrays can be run in sync or async mode. ByteArrays will issue events for key state transitions such as 
close, EOF, readable and writable events. All event observers are called with the following signature:
function callback(event: String, ba: ByteArray): Void.</p>

</div>


<hr />
<a name='Properties'></a>
<h2 class='classSection'>Properties</h2>
<table class='itemTable' title='properties'>
   <tr><th>Qualifiers</th><th>Property</th><th>Type</th><th width='95%'>Description</th></tr>
<a name='BigEndian'></a>
   <tr><td nowrap align='center'> static const </td><td>BigEndian</td><td><a href='Number.html'>Number</a></td><td>Big endian byte order used for the <a href='#endian'>endian</a> property. </td></tr>
<a name='LittleEndian'></a>
   <tr><td nowrap align='center'> static const </td><td>LittleEndian</td><td><a href='Number.html'>Number</a></td><td>Little endian byte order used for the <a href='#endian'>endian</a> property
0. </td></tr>
<a name='MD5'></a>
   <tr><td nowrap align='center'> get </td><td>MD5</td><td><a href='String.html'>String</a></td><td>An MD5 checksum for the buffer contents
(. </td></tr>
<a name='async'></a>
   <tr><td nowrap align='center'> get set </td><td>async</td><td><a href='Boolean.html'>Boolean</a></td><td>The current async mode. Set to true if the stream is in async mode.</td></tr>
<a name='encoding'></a>
   <tr><td nowrap align='center'> get set </td><td>encoding</td><td><a href='String.html'>String</a></td><td>Current encoding scheme for serializing strings. The default encoding is "utf-8". Set to "" for no encoding.
If no encoding, string character points are stored as a pairs of two byte in little-endian format.</td></tr>
<a name='endian'></a>
   <tr><td nowrap align='center'> get set </td><td>endian</td><td><a href='Number.html'>Number</a></td><td>Current byte ordering for storing and retrieving numbers. Set to either LittleEndian or BigEndian.</td></tr>
<a name='length'></a>
   <tr><td nowrap align='center'> get </td><td>length</td><td><a href='Number.html'>Number</a></td><td>Number of bytes that are currently available for reading. This consists of the bytes available
from the current <a href='#readPosition'>readPosition</a> up to the current writePosition. To get the total size of the ByteArray
use <a href='#size'>size</a>. </td></tr>
<a name='readPosition'></a>
   <tr><td nowrap align='center'> get set </td><td>readPosition</td><td><a href='Number.html'>Number</a></td><td>Current read position offset. </td></tr>
<a name='resizable'></a>
   <tr><td nowrap align='center'> get </td><td>resizable</td><td><a href='Boolean.html'>Boolean</a></td><td>Is the ByteArray is resizable. </td></tr>
<a name='room'></a>
   <tr><td nowrap align='center'> get </td><td>room</td><td><a href='Number.html'>Number</a></td><td>Number of data bytes that the array can store from the <a href='#writePosition'>writePosition</a> till the end of the array. </td></tr>
<a name='size'></a>
   <tr><td nowrap align='center'> get </td><td>size</td><td><a href='Number.html'>Number</a></td><td>Size of the byte array. This is not the amount of read or write data, but is the size of the total 
array storage. Use <a href='#length'>length</a> to get the amount of data between the read and write positions.</td></tr>
<a name='writePosition'></a>
   <tr><td nowrap align='center'> get set </td><td>writePosition</td><td><a href='Number.html'>Number</a></td><td>Current <a href='#writePosition'>writePosition</a> offset. 8.</td></tr>
</table>

<p class='inheritedLink'><a href='Object.html#Properties'><i>Inherited Properties</i></a></p>

<hr />
<a name='ClassMethods'></a>
<h2 class='classSection'>ByteArray Class Methods</h2>
<table class='apiIndex' title='methods'>
   <tr><th>Qualifiers</th><th width='95%'>Method</th></tr>
   <p>(No own class methods defined)</p></table>

<p class='inheritedLink'><a href='Object.html#InstanceMethods'><i>Inherited Methods</i></a></p>

<hr />
<a name='InstanceMethods'></a>
<h2 class='classSection'>ByteArray Instance Methods</h2>
<table class='apiIndex' title='methods'>
   <tr><th>Qualifiers</th><th width='95%'>Method</th></tr>
   <tr class='apiDef'><td class='apiType'></td><td><a href='#ByteArray'><b>ByteArray</b></a>(size: <a href='Number.html'>Number</a> = -1, resizable: <a href='Boolean.html'>Boolean</a> = true)</tr><tr class='apiBrief'><td>&nbsp;</td><td>Create a new array.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#close'><b>close</b></a>(): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Close the stream.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#compact'><b>compact</b></a>(): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Compact available data down and adjust the read/write positions accordingly.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#copyIn'><b>copyIn</b></a>(destOffset: <a href='Number.html'>Number</a>, src: <a href='ByteArray.html'>ByteArray</a>, srcOffset: <a href='Number.html'>Number</a> = 0, count: <a href='Number.html'>Number</a> = -1): <a href='Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Copy data into the array.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#copyOut'><b>copyOut</b></a>(srcOffset: <a href='Number.html'>Number</a>, dest: <a href='ByteArray.html'>ByteArray</a>, destOffset: <a href='Number.html'>Number</a> = 0, count: <a href='Number.html'>Number</a> = -1): <a href='Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Copy data from the array.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#flush'><b>flush</b></a>(dir: <a href='Number.html'>Number</a> = expression): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Flush (discard) the data in the byte array and reset the read and write positions.</td></tr>
   <tr class='apiDef'><td class='apiType'>iterator override </td><td><a href='#get'><b>get</b></a>(): <a href='iterator-Iterator.html'>Iterator</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Iterator for this array to be used by "for (v in array)".</td></tr>
   <tr class='apiDef'><td class='apiType'>iterator override </td><td><a href='#getValues'><b>getValues</b></a>(): <a href='iterator-Iterator.html'>Iterator</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Iterator for this array to be used by "for each (v in array)".</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#off'><b>off</b></a>(name: <a href='Object.html'>Object</a>, observer: <a href='Function.html'>Function</a>): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Remove an observer from the stream.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#on'><b>on</b></a>(name: <a href='Object.html'>Object</a>, observer: <a href='Function.html'>Function</a>): <a href='ByteArray.html'>ByteArray</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Add an observer to the stream for the named events.H.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#read'><b>read</b></a>(buffer: <a href='ByteArray.html'>ByteArray</a>, offset: <a href='Number.html'>Number</a> = 0, count: <a href='Number.html'>Number</a> = -1): <a href='Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read a data from the stream.Data is read from the current read <a href='#position'>position</a> pointer toward the current <a href='#writePosition'>writePosition</a>. </td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#readBoolean'><b>readBoolean</b></a>(): <a href='Boolean.html'>Boolean</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read a boolean from the array.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#readByte'><b>readByte</b></a>(): <a href='Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read a byte from the array.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#readDate'><b>readDate</b></a>(): <a href='Date.html'>Date</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read a date from the array.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#readDouble'><b>readDouble</b></a>(): <a href='Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read a double from the array.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#readInteger'><b>readInteger</b></a>(): <a href='Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read an 32-bit integer from the array.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#readLong'><b>readLong</b></a>(): <a href='Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read a 64-bit long from the array.The data will be decoded according to the endian property.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#readShort'><b>readShort</b></a>(): <a href='Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read a 16-bit short integer from the array.The data will be decoded according to the endian property.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#readString'><b>readString</b></a>(count: <a href='Number.html'>Number</a> = -1): <a href='String.html'>String</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read a data from the array as a string.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#readXML'><b>readXML</b></a>(): <a href='XML.html'>XML</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read an XML document from the array.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#reset'><b>reset</b></a>(): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Reset the read and <a href='#writePosition'>writePosition</a> pointers if there is no available data.</td></tr>
   <tr class='apiDef'><td class='apiType'> override </td><td><a href='#toString'><b>toString</b></a>(): <a href='String.html'>String</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Convert the data in the byte array between the <a href='#readPosition'>readPosition</a> and writePosition.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#write'><b>write</b></a>(data: <a href='Array.html'>Array</a>): <a href='Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Write data to the stream.Write data to the ByteArray.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#writeByte'><b>writeByte</b></a>(data: <a href='Number.html'>Number</a>): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Write a byte to the array.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#writeDouble'><b>writeDouble</b></a>(data: <a href='Number.html'>Number</a>): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Write a double to the array.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#writeInteger'><b>writeInteger</b></a>(data: <a href='Number.html'>Number</a>): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Write a 32-bit integer to the array.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#writeLong'><b>writeLong</b></a>(data: <a href='Number.html'>Number</a>): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Write a 64 bit long integer to the array.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#writeShort'><b>writeShort</b></a>(data: <a href='Number.html'>Number</a>): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Write a short to the array.</td></tr>
</table>

<p class='inheritedLink'><a href='Object.html#InstanceMethods'><i>Inherited Methods</i></a></p>

<hr />
<h2>Method Detail</h2>
<a name='ByteArray'></a>
<div class='api'>
<div class='apiSig'>    ByteArray(size: <a href='Number.html'>Number</a> = -1, resizable: <a href='Boolean.html'>Boolean</a> = true)
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Create a new array. </dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>size: <a href='Number.html'>Number</a> </td><td>The initial size of the byte array. If not supplied a default buffer size will be used which is typically 4K or larger. [default: -1]</td></tr><tr class='param'><td class='param'>resizable: <a href='Boolean.html'>Boolean</a> </td><td>Set to true to automatically grow the array as required to fit written data. [default: true]</td></tr></table></dd>
</dl></div>
</div>
<hr />
<a name='close'></a>
<div class='api'>
<div class='apiSig'>    close(): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Close the stream. </dd></dl>
<dl><dt>Events</dt>
<dd><table class='parameters' title='events'>
<td class='param'>close</td><td>A close event is issued before closing the stream.</td></tr>
</table></dd>
</dl></div>
</div>
<hr />
<a name='compact'></a>
<div class='api'>
<div class='apiSig'>    compact(): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Compact available data down and adjust the read/write positions accordingly. This sets the read pointer 
to the zero index and adjusts the write pointer by the corresponding amount.</dd></dl>
</div>
</div>
<hr />
<a name='copyIn'></a>
<div class='api'>
<div class='apiSig'>    copyIn(destOffset: <a href='Number.html'>Number</a>, src: <a href='ByteArray.html'>ByteArray</a>, srcOffset: <a href='Number.html'>Number</a> = 0, count: <a href='Number.html'>Number</a> = -1): <a href='Number.html'>Number</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Copy data into the array. This is a low-level data copy routine that does not update read and write positions.
Data is written at the destOffset index. This call does not issue events unless required to make room
for the incoming data ("readable" event).</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>destOffset: <a href='Number.html'>Number</a> </td><td>Index in the destination byte array to copy the data to.</td></tr><tr class='param'><td class='param'>src: <a href='ByteArray.html'>ByteArray</a> </td><td>Source byte array containing the data elements to copy.</td></tr><tr class='param'><td class='param'>srcOffset: <a href='Number.html'>Number</a> </td><td>Location in the source buffer from which to copy the data. Defaults to the start. [default: 0]</td></tr><tr class='param'><td class='param'>count: <a href='Number.html'>Number</a> </td><td>Number of bytes to copy. Set to -1 to read all the src buffer. [default: -1]</td></tr></table></dd>
</dl><dl><dt>Returns</dt>
<dd>The number of bytes written into the array. If the array is not resizable and there is insufficient room, this may be less than the requested amount.</dd></dl>
</div>
</div>
<hr />
<a name='copyOut'></a>
<div class='api'>
<div class='apiSig'>    copyOut(srcOffset: <a href='Number.html'>Number</a>, dest: <a href='ByteArray.html'>ByteArray</a>, destOffset: <a href='Number.html'>Number</a> = 0, count: <a href='Number.html'>Number</a> = -1): <a href='Number.html'>Number</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Copy data from the array. Data is copied from the srcOffset pointer. This call does not update the 
read and write positions. This call does not issue events.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>srcOffset: <a href='Number.html'>Number</a> </td><td>Location in the source array from which to copy data.</td></tr><tr class='param'><td class='param'>dest: <a href='ByteArray.html'>ByteArray</a> </td><td>Destination byte array.</td></tr><tr class='param'><td class='param'>destOffset: <a href='Number.html'>Number</a> </td><td>Location in the destination array to copy the data. Defaults to the start. [default: 0]</td></tr><tr class='param'><td class='param'>count: <a href='Number.html'>Number</a> </td><td>Number of bytes to read. Set to -1 to read all available data. [default: -1]</td></tr></table></dd>
</dl><dl><dt>Returns</dt>
<dd>The count of bytes read. Returns null on EOF.</dd></dl>
</div>
</div>
<hr />
<a name='flush'></a>
<div class='api'>
<div class='apiSig'>    flush(dir: <a href='Number.html'>Number</a> = expression): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Flush (discard) the data in the byte array and reset the read and write positions. This call may block if the stream is in sync mode.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>dir: <a href='Number.html'>Number</a> </td><td>The dir parameter is Ignored. Flushing a ByteArray in either direction the same effect of  discarding all buffered data and resetting the read and write positions -- so this argument is ignored. [default: expression]</td></tr></table></dd>
</dl></div>
</div>
<hr />
<a name='get'></a>
<div class='api'>
<div class='apiSig'>override   iterator  get(): <a href='iterator-Iterator.html'>Iterator</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Iterator for this array to be used by "for (v in array)". This will return array indicies.</dd></dl>
</div>
</div>
<hr />
<a name='getValues'></a>
<div class='api'>
<div class='apiSig'>override   iterator  getValues(): <a href='iterator-Iterator.html'>Iterator</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Iterator for this array to be used by "for each (v in array)". This will return read data in the array.</dd></dl>
</div>
</div>
<hr />
<a name='off'></a>
<div class='api'>
<div class='apiSig'>    off(name: <a href='Object.html'>Object</a>, observer: <a href='Function.html'>Function</a>): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Remove an observer from the stream. </dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>name: <a href='Object.html'>Object</a> </td><td>Event name previously used with observe. The name may be an array of events.</td></tr><tr class='param'><td class='param'>observer: <a href='Function.html'>Function</a> </td><td>Observer function previously used with observe.</td></tr></table></dd>
</dl></div>
</div>
<hr />
<a name='on'></a>
<div class='api'>
<div class='apiSig'>    on(name: <a href='Object.html'>Object</a>, observer: <a href='Function.html'>Function</a>): <a href='ByteArray.html'>ByteArray</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Add an observer to the stream for the named events.H. </dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>name: <a href='Object.html'>Object</a> </td><td>Name of the event to listen for. The name may be an array of events.</td></tr><tr class='param'><td class='param'>observer: <a href='Function.html'>Function</a> </td><td>Callback observer function. The function is called with the following signature: function observer(event: String, ...args): Void.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' title='events'>
<td class='param'>readable</td><td>Issued when the stream becomes readable.</td></tr>
<td class='param'>writable</td><td>Issued when the stream becomes writable.</td></tr>
<td class='param'>close</td><td>Issued when stream is being closed. 8.</td></tr>
</table></dd>
</dl></div>
</div>
<hr />
<a name='read'></a>
<div class='api'>
<div class='apiSig'>    read(buffer: <a href='ByteArray.html'>ByteArray</a>, offset: <a href='Number.html'>Number</a> = 0, count: <a href='Number.html'>Number</a> = -1): <a href='Number.html'>Number</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Read a data from the stream.Data is read from the current read <a href='#position'>position</a> pointer toward the current <a href='#writePosition'>writePosition</a>.  If data is available, the call will return immediately. 
If no data is available and the stream is in sync mode, the call will block until data is available.
If no data is available and the stream is in async mode, the call will not block and will return immediately.
In this case a "readable" event will be issued when data is available for reading.This byte array's <a href='#readPosition'>readPosition</a> is updated. If offset is < 0, then data is copied to the destination buffer's 
<a href='#writePosition'>writePosition</a> and the destination buffer's <a href='#writePosition'>writePosition</a> is also updated. If the offset is >= 0, the 
read position is set to the specified offset and data is stored at this offset. The write position is set to
one past the last byte read.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>buffer: <a href='ByteArray.html'>ByteArray</a> </td><td>Destination byte array for read data.</td></tr><tr class='param'><td class='param'>offset: <a href='Number.html'>Number</a> </td><td>Offset in the byte array to place the data. If the offset is -1, then data is appended to the buffer write <a href='#position'>position</a> which is then updated. If offset is >= 0, the data is read  to the offset and the read pointer is set to the offset and the write pointer to one past the end of  the data just read. [default: 0]</td></tr><tr class='param'><td class='param'>count: <a href='Number.html'>Number</a> </td><td>Read up to this number of bytes. If -1, read as much as the buffer will hold up. If the  stream is of fixed and known length (such as a file) and the buffer is of sufficient size or is growable,  read the entire stream. If the buffer is of a fixed size, ready only what will fit into the buffer. [default: -1]</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' title='events'>
<td class='param'>readable</td><td>Issued when there is new read data available.</td></tr>
<td class='param'>writable</td><td>Issued when the stream becomes empty. `.</td></tr>
</table></dd>
</dl><dl><dt>Returns</dt>
<dd>A count of the bytes actually read. Returns null on EOF or errors.</dd></dl>
</div>
</div>
<hr />
<a name='readBoolean'></a>
<div class='api'>
<div class='apiSig'>    readBoolean(): <a href='Boolean.html'>Boolean</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Read a boolean from the array. Data is read from the current read <a href='#position'>position</a> pointer.
If insufficient data, a "writable" event will be issued indicating that the byte array is writable. This enables 
observers to write data into the byte array.  If there is no data available, the call 
will return return null indicating EOF.</dd></dl>
<dl><dt>Returns</dt>
<dd>A boolean or null on EOF.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if an I/O error occurs or premature EOF.
</dd>
</dl></div>
</div>
<hr />
<a name='readByte'></a>
<div class='api'>
<div class='apiSig'>    readByte(): <a href='Number.html'>Number</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Read a byte from the array. Data is read from the current read <a href='#position'>position</a> pointer.
If insufficient data, a "write" event will be issued indicating that the byte array is 
writable.  This enables observers to write data into the byte array.  If there is no data available, the call 
will return return null indicating EOF.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if an I/O error occurs or premature EOF.
</dd>
</dl></div>
</div>
<hr />
<a name='readDate'></a>
<div class='api'>
<div class='apiSig'>    readDate(): <a href='Date.html'>Date</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Read a date from the array. Data is read from the current read <a href='#position'>position</a> pointer.
If insufficient data, a "write" event will be issued indicating that the byte array is 
writable.  This enables observers to write data into the byte array.  If there is no data available, the call 
will return return null indicating EOF.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if an I/O error occurs or premature EOF.
</dd>
</dl></div>
</div>
<hr />
<a name='readDouble'></a>
<div class='api'>
<div class='apiSig'>    readDouble(): <a href='Number.html'>Number</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Read a double from the array. The data will be decoded according to the endian property. Data is read 
from the current read <a href='#position'>position</a> pointer. If insufficient data, a "write" event will be issued indicating 
that the byte array is writable. This enables observers to write data into the byte array. If there is 
no data available, the call will return return null indicating EOF.</dd></dl>
<dl><dt>Returns</dt>
<dd>A double or null on EOF.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if an I/O error occurs or premature EOF.
</dd>
</dl></div>
</div>
<hr />
<a name='readInteger'></a>
<div class='api'>
<div class='apiSig'>    readInteger(): <a href='Number.html'>Number</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Read an 32-bit integer from the array. The data will be decoded according to the endian property.
Data is read from the current read <a href='#position'>position</a> pointer.
If insufficient data, a "write" event will be issued indicating that the byte array is 
writable.  This enables observers to write data into the byte array.  If there is no data available, the call 
will return return null indicating EOF.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if an I/O error occurs or premature EOF.
</dd>
</dl></div>
</div>
<hr />
<a name='readLong'></a>
<div class='api'>
<div class='apiSig'>    readLong(): <a href='Number.html'>Number</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Read a 64-bit long from the array.The data will be decoded according to the endian property. Data is read from the current read <a href='#position'>position</a> pointer.
If insufficient data, a "write" event will be issued indicating that the byte array is 
writable.  This enables observers to write data into the byte array.  If there is no data available, the call 
will return return null indicating EOF.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if an I/O error occurs or premature EOF. 0
</dd>
</dl></div>
</div>
<hr />
<a name='readShort'></a>
<div class='api'>
<div class='apiSig'>    readShort(): <a href='Number.html'>Number</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Read a 16-bit short integer from the array.The data will be decoded according to the endian property. Data is read from the current read <a href='#position'>position</a> pointer.
If insufficient data, a "write" event will be issued indicating that the byte array is 
writable.  This enables observers to write data into the byte array.  If there is no data available, the call 
will return return null indicating EOF. If there is insufficient data.</dd></dl>
<dl><dt>Returns</dt>
<dd>A short int or null on EOF.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if an I/O error occurs or premature EOF.
</dd>
</dl></div>
</div>
<hr />
<a name='readString'></a>
<div class='api'>
<div class='apiSig'>    readString(count: <a href='Number.html'>Number</a> = -1): <a href='String.html'>String</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Read a data from the array as a string. Read data from the <a href='#readPosition'>readPosition</a> to a string up to the <a href='#writePosition,
'>writePosition,
</a> but not more than count characters. If insufficient data, a "writable" event will be issued indicating that 
the byte array is writable. This enables observers to write data into the byte array.  If there is no data 
available, the call will return return null indicating EOF. If there is insufficient data.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>count: <a href='Number.html'>Number</a> </td><td>Of bytes to read. If -1, convert the data up to the <a href='#writePosition'>writePosition</a>.  [default: -1]</td></tr></table></dd>
</dl><dl><dt>Returns</dt>
<dd>A string or null on EOF.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if an I/O error occurs or a premature EOF.
</dd>
</dl></div>
</div>
<hr />
<a name='readXML'></a>
<div class='api'>
<div class='apiSig'>    readXML(): <a href='XML.html'>XML</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Read an XML document from the array. Data is read from the current read <a href='#position'>position</a> pointer.</dd></dl>
<dl><dt>Returns</dt>
<dd>An XML document.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if an I/O error occurs or a premature end of file.
</dd>
</dl></div>
</div>
<hr />
<a name='reset'></a>
<div class='api'>
<div class='apiSig'>    reset(): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Reset the read and <a href='#writePosition'>writePosition</a> pointers if there is no available data. This is used to rewind the read/write pointers to maximize available buffer space.</dd></dl>
</div>
</div>
<hr />
<a name='toString'></a>
<div class='api'>
<div class='apiSig'>override     toString(): <a href='String.html'>String</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Convert the data in the byte array between the <a href='#readPosition'>readPosition</a> and writePosition. </dd></dl>
<dl><dt>Returns</dt>
<dd>A string.</dd></dl>
</div>
</div>
<hr />
<a name='write'></a>
<div class='api'>
<div class='apiSig'>    write(data: <a href='Array.html'>Array</a>): <a href='Number.html'>Number</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Write data to the stream.Write data to the ByteArray. If the stream can accept all the write data, the call returns immediately with the number of bytes written. 
If writing more data than the stream can absorb in sync mode, the call will block until the data is written.
If writing more data than the stream can absorb in async mode, the call will not block and will buffer the
data and return immediately. Some streams will require a <a href='#flush'>flush()</a> call to actually send the data.
A "writable" event will be issued when the stream can again absorb more data.Data is written to the current writePosition. If the data argument is itself a ByteArray, the available data 
from the byte array will be copied, ie. the <a href='#data'>data</a> byte array will not have its readPosition adjusted. If the 
byte array is resizable, the underlying data storage will grow to accomodate written data. If the data will not
fit in the ByteArray, the call may return having only written a portion of the data.
When strings are written, they are not null terminated.
0</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>data: <a href='Array.html'>Array</a> </td><td>Data to write.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' title='events'>
<td class='param'>readable</td><td>Issued when data is written and a consumer can read without blocking.</td></tr>
<td class='param'>writable</td><td>Issued when the stream becomes empty and it is ready to be written to.</td></tr>
</table></dd>
</dl><dl><dt>Returns</dt>
<dd>A count of the bytes actually written.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if there is an I/O error.
</dd>
</dl></div>
</div>
<hr />
<a name='writeByte'></a>
<div class='api'>
<div class='apiSig'>    writeByte(data: <a href='Number.html'>Number</a>): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Write a byte to the array. Data is written to the current write <a href='#position'>position</a> pointer which is then incremented.
See <a href='#write'>write</a> for details about sync, async modes and event handling.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>data: <a href='Number.html'>Number</a> </td><td>Data to write.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' title='events'>
<td class='param'>readable</td><td>Issued when data is written and a consumer can read without blocking.</td></tr>
</table></dd>
</dl><dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if an I/O error occurs or if the stream cannot absorb all the data.
</dd>
</dl></div>
</div>
<hr />
<a name='writeDouble'></a>
<div class='api'>
<div class='apiSig'>    writeDouble(data: <a href='Number.html'>Number</a>): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Write a double to the array. Data is written to the current write <a href='#position'>position</a> pointer which is then incremented.
See <a href='#write'>write</a> for details about sync, async modes and event handling.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>data: <a href='Number.html'>Number</a> </td><td>Data to write.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' title='events'>
<td class='param'>readable</td><td>Issued when data is written and a consumer can read without blocking.</td></tr>
</table></dd>
</dl><dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if an I/O error occurs or if the stream cannot absorb all the data.
</dd>
</dl></div>
</div>
<hr />
<a name='writeInteger'></a>
<div class='api'>
<div class='apiSig'>    writeInteger(data: <a href='Number.html'>Number</a>): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Write a 32-bit integer to the array. Data is written to the current write <a href='#position'>position</a> pointer which is 
then incremented.
See <a href='#write'>write</a> for details about sync, async modes and event handling.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>data: <a href='Number.html'>Number</a> </td><td>Data to write.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' title='events'>
<td class='param'>readable</td><td>Issued when data is written and a consumer can read without blocking.</td></tr>
</table></dd>
</dl><dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if an I/O error occurs or if the stream cannot absorb all the data.
</dd>
</dl></div>
</div>
<hr />
<a name='writeLong'></a>
<div class='api'>
<div class='apiSig'>    writeLong(data: <a href='Number.html'>Number</a>): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Write a 64 bit long integer to the array. Data is written to the current write <a href='#position'>position</a> pointer which is 
then incremented.
See <a href='#write'>write</a> for details about sync, async modes and event handling.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>data: <a href='Number.html'>Number</a> </td><td>Data to write.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' title='events'>
<td class='param'>readable</td><td>Issued when data is written and a consumer can read without blocking.</td></tr>
</table></dd>
</dl><dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if an I/O error occurs or if the stream cannot absorb all the data.
</dd>
</dl></div>
</div>
<hr />
<a name='writeShort'></a>
<div class='api'>
<div class='apiSig'>    writeShort(data: <a href='Number.html'>Number</a>): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Write a short to the array. Data is written to the current write <a href='#position'>position</a> pointer which is then incremented.
See <a href='#write'>write</a> for details about sync, async modes and event handling.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>data: <a href='Number.html'>Number</a> </td><td>Data to write.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' title='events'>
<td class='param'>readable</td><td>Issued when data is written and a consumer can read without blocking.</td></tr>
</table></dd>
</dl><dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if an I/O error occurs or if the stream cannot absorb all the data.
</dd>
</dl></div>
</div>
<hr />
<div class="terms">
   <p class="terms">
       <a href="https://www.embedthis.com/">       Embedthis Software LLC, 2003-2014. All rights reserved. Embedthis is a trademark of Embedthis Software LLC.</a>
   </p>
</div></div>
</div>
</body>
</html>
