<!DOCTYPE html>
<html>
<head>
   <title>Class Socket</title>

   <link rel="stylesheet" type="text/css" href="doc.css" />
</head>

<body>
<div class='body'>

<div class="content">

<a name='top'></a>
<h1 class='className'>Socket</h1>
<div class='classBlock'>
<table class='classHead' title='Socket'>
   <tr><td><strong>Module</strong></td><td>ejs</td></tr>
   <tr><td><strong>Definition</strong></td><td> class Socket</td></tr>
   <tr><td><strong>Inheritance</strong></td><td>Socket <img src='images/inherit.gif' alt='inherit'/> <a href='Object.html'>Object</a><tr><td><strong>Specified</strong></td><td>ejscript-2.5</td></tr>
<tr><td><strong>Stability</strong></td><td>Prototype.</td></tr>
       </td></tr>
</table>

<p class='classBrief'>Client and server side TCP/IP support for IPv4 and IPv6 communications.</p>

<p class='classDescription'>This class supports broadcast, datagram and
byte-stream socket sevices for both client and server endpoints. Aynchronous and asynchronous operation is supported.</p>

</div>


<hr />
<a name='Properties'></a>
<h2 class='classSection'>Properties</h2>
<table class='itemTable' title='properties'>
   <tr><th>Qualifiers</th><th>Property</th><th>Type</th><th width='95%'>Description</th></tr>
<a name='address'></a>
   <tr><td nowrap align='center'> get </td><td>address</td><td><a href='String.html'>String</a></td><td>Local IP address bound to this socket. Set to the address in dot notation or empty string if it is not bound.</td></tr>
<a name='async'></a>
   <tr><td nowrap align='center'> get set </td><td>async</td><td><a href='Boolean.html'>Boolean</a></td><td>The current async mode. Set to true if the stream is in async mode.</td></tr>
<a name='encoding'></a>
   <tr><td nowrap align='center'> get set </td><td>encoding</td><td><a href='String.html'>String</a></td><td>Current encoding scheme for serializing strings. Defaults to "utf-8".</td></tr>
<a name='isEof'></a>
   <tr><td nowrap align='center'> get </td><td>isEof</td><td><a href='Boolean.html'>Boolean</a></td><td>Is the socket at end of input. I.e. Is closed or has the other end sent a FIN packet.</td></tr>
<a name='port'></a>
   <tr><td nowrap align='center'> get </td><td>port</td><td><a href='Number.html'>Number</a></td><td>The port bound to this socket. Set to the integer port number or zero if not bound.</td></tr>
<a name='remoteAddress'></a>
   <tr><td nowrap align='center'> get </td><td>remoteAddress</td><td><a href='String.html'>String</a></td><td>The remote address bound to this socket. Set to the remote address in dot notation or empty string if it 
is not bound.</td></tr>
</table>

<p class='inheritedLink'><a href='Object.html#Properties'><i>Inherited Properties</i></a></p>

<hr />
<a name='ClassMethods'></a>
<h2 class='classSection'>Socket Class Methods</h2>
<table class='apiIndex' title='methods'>
   <tr><th>Qualifiers</th><th width='95%'>Method</th></tr>
   <p>(No own class methods defined)</p></table>

<p class='inheritedLink'><a href='Object.html#InstanceMethods'><i>Inherited Methods</i></a></p>

<hr />
<a name='InstanceMethods'></a>
<h2 class='classSection'>Socket Instance Methods</h2>
<table class='apiIndex' title='methods'>
   <tr><th>Qualifiers</th><th width='95%'>Method</th></tr>
   <tr class='apiDef'><td class='apiType'></td><td><a href='#Socket'><b>Socket</b></a>()</tr><tr class='apiBrief'><td>&nbsp;</td><td>Create a socket object
(.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#accept'><b>accept</b></a>(): <a href='Socket.html'>Socket</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Receive a client socket.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#close'><b>close</b></a>(): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Close the stream.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#connect'><b>connect</b></a>(address: <a href='Object.html'>Object</a>): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Establish a connection to a client from this socket to the supplied address.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#flush'><b>flush</b></a>(dir: <a href='Number.html'>Number</a>): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Flush the stream and underlying streams.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#listen'><b>listen</b></a>(address): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Listen on a socket for client connections.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#off'><b>off</b></a>(name: <a href='Object.html'>Object</a>, observer: <a href='Function.html'>Function</a>): <a href='Void.html'>Void</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Remove an observer from the stream.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#on'><b>on</b></a>(name, observer: <a href='Function.html'>Function</a>): <a href='Socket.html'>Socket</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Add an observer to the stream for the named events.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#read'><b>read</b></a>(buffer: <a href='ByteArray.html'>ByteArray</a>, offset: <a href='Number.html'>Number</a>, count: <a href='Number.html'>Number</a> = -1): <a href='Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Read a data from the stream.</td></tr>
   <tr class='apiDef'><td class='apiType'> </td><td><a href='#write'><b>write</b></a>(data: <a href='Array.html'>Array</a>): <a href='Number.html'>Number</a></tr><tr class='apiBrief'><td>&nbsp;</td><td>Write data to the stream.</td></tr>
</table>

<p class='inheritedLink'><a href='Object.html#InstanceMethods'><i>Inherited Methods</i></a></p>

<hr />
<h2>Method Detail</h2>
<a name='Socket'></a>
<div class='api'>
<div class='apiSig'>    Socket()
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Create a socket object
(. </dd></dl>
</div>
</div>
<hr />
<a name='accept'></a>
<div class='api'>
<div class='apiSig'>    accept(): <a href='Socket.html'>Socket</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Receive a client socket. Accept must be called after invoking <a href='#listen'>listen</a>. </dd></dl>
<dl><dt>Returns</dt>
<dd>A socket connected to the client endpoint. 0.</dd></dl>
</div>
</div>
<hr />
<a name='close'></a>
<div class='api'>
<div class='apiSig'>    close(): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Close the stream. </dd></dl>
<dl><dt>Events</dt>
<dd><table class='parameters' title='events'>
<td class='param'>close</td><td>A close event is issued before closing the stream.</td></tr>
</table></dd>
</dl></div>
</div>
<hr />
<a name='connect'></a>
<div class='api'>
<div class='apiSig'>    connect(address: <a href='Object.html'>Object</a>): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Establish a connection to a client from this socket to the supplied address. After a successful call to 
connect() the socket may be used for sending and receiving.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>address: <a href='Object.html'>Object</a> </td><td>The endpoint address on which to listen. The address can be either a port number, an IP address string, a composite "IP:PORT" string or a port number string. If only a port number is provided,  the socket will listen on all interfaces.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' title='events'>
<td class='param'>Issues</td><td>A "writable" event when the connection is complete.</td></tr>
</table></dd>
</dl><dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if the connection fails. Reasons may include the socket is already bound or the host is unknown.
</dd>
</dl></div>
</div>
<hr />
<a name='flush'></a>
<div class='api'>
<div class='apiSig'>    flush(dir: <a href='Number.html'>Number</a>): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Flush the stream and underlying streams. A supplied flush <a href='#direction'>direction</a> argument modifies the effect of this call.
If direction is set to Stream.READ, then all read data is discarded. If direction is set to Stream.WRITE, 
any buffered data is written. Stream.BOTH will cause both directions to be flushed. If the stream is in 
sync mode, this call will block until all data is written. If the stream is in async mode, it will attempt 
to write all data but will return immediately. Defaults to Stream.WRITE.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>dir: <a href='Number.html'>Number</a> </td><td>Direction to flush. Set to <a href='#READ'>READ</a> <a href='#WRITE'>WRITE</a> or <a href='#BOTH'>BOTH</a>.</td></tr></table></dd>
</dl></div>
</div>
<hr />
<a name='listen'></a>
<div class='api'>
<div class='apiSig'>    listen(address): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Listen on a socket for client connections. This will put the socket into a server role for communcations.
If the socket is in sync mode, the listen call will block until a client connection is received after which
accept() should be called to receive the socket instance for the new connection.
If a the listening socket is in async mode, the listen call will return immediately and 
client connections will be notified via "accept" events.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>address </td><td>The endpoint address on which to listen. The address can be either a port number, an IP address string or a composite "IP:PORT" string. If only a port number is provided, the socket will listen on all interfaces.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' title='events'>
<td class='param'>Issues</td><td>A "accept" event when there is a new connection available. In response, the <a href='#accept'>accept</a> method should be called.</td></tr>
</table></dd>
</dl><dl><dt>Throws</dt><dd>
<a href='ArgError.html'>ArgError</a>: if the specified listen address is not valid, and IOError for network errors.
</dd>
</dl></div>
</div>
<hr />
<a name='off'></a>
<div class='api'>
<div class='apiSig'>    off(name: <a href='Object.html'>Object</a>, observer: <a href='Function.html'>Function</a>): <a href='Void.html'>Void</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Remove an observer from the stream. </dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>name: <a href='Object.html'>Object</a> </td><td>Event name previously used with observe. The name may be an array of events.</td></tr><tr class='param'><td class='param'>observer: <a href='Function.html'>Function</a> </td><td>Observer function previously used with observe.</td></tr></table></dd>
</dl></div>
</div>
<hr />
<a name='on'></a>
<div class='api'>
<div class='apiSig'>    on(name, observer: <a href='Function.html'>Function</a>): <a href='Socket.html'>Socket</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Add an observer to the stream for the named events. </dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>name: [String|Array]</td><td>Name of the event to listen for. The name may be an array of events.</td></tr><tr class='param'><td class='param'>observer: <a href='Function.html'>Function</a> </td><td>Callback observer function. The function is called with the following signature: function observer(event: String, ...args): Void.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' title='events'>
<td class='param'>readable</td><td>Issued when the stream becomes readable.</td></tr>
<td class='param'>writable</td><td>Issued when the stream becomes writable.</td></tr>
<td class='param'>close</td><td>Issued when stream is being closed. 8.</td></tr>
<td class='param'>writable</td><td>Issued when the connection is writable to accept body data (PUT, POST).</td></tr>
</table></dd>
</dl></div>
</div>
<hr />
<a name='read'></a>
<div class='api'>
<div class='apiSig'>    read(buffer: <a href='ByteArray.html'>ByteArray</a>, offset: <a href='Number.html'>Number</a>, count: <a href='Number.html'>Number</a> = -1): <a href='Number.html'>Number</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Read a data from the stream. If data is available, the call will return immediately. 
If no data is available and the stream is in sync mode, the call will block until data is available.
If no data is available and the stream is in async mode, the call will not block and will return immediately.
In this case a "readable" event will be issued when data is available for reading.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>buffer: <a href='ByteArray.html'>ByteArray</a> </td><td>Destination byte array for read data.</td></tr><tr class='param'><td class='param'>offset: <a href='Number.html'>Number</a> </td><td>Offset in the byte array to place the data. If the offset is -1, then data is appended to the buffer write <a href='#position'>position</a> which is then updated. If offset is >= 0, the data is read  to the offset and the read pointer is set to the offset and the write pointer to one past the end of  the data just read.</td></tr><tr class='param'><td class='param'>count: <a href='Number.html'>Number</a> </td><td>Read up to this number of bytes. If -1, read as much as the buffer will hold up. If the  stream is of fixed and known length (such as a file) and the buffer is of sufficient size or is growable,  read the entire stream. If the buffer is of a fixed size, ready only what will fit into the buffer. [default: -1]</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' title='events'>
<td class='param'>readable</td><td>Issued when there is new read data available.</td></tr>
<td class='param'>writable</td><td>Issued when the stream becomes empty. `.</td></tr>
</table></dd>
</dl><dl><dt>Returns</dt>
<dd>A count of the bytes actually read. Returns null on EOF or errors.</dd></dl>
</div>
</div>
<hr />
<a name='write'></a>
<div class='api'>
<div class='apiSig'>    write(data: <a href='Array.html'>Array</a>): <a href='Number.html'>Number</a>
</div>
<div class='apiDetail'>
<dl><dt>Description</dt></dd><dd>Write data to the stream. If the stream can accept all the write data, the call returns immediately with the number of bytes written. 
If writing more data than the stream can absorb in sync mode, the call will block until the data is written.
If writing more data than the stream can absorb in async mode, the call will not block and will buffer the
data and return immediately. Some streams will require a <a href='#flush'>flush()</a> call to actually send the data.
A "writable" event will be issued when the stream can again absorb more data.</dd></dl>
<dl><dt>Parameters</dt>
<dd><table class='parameters' title='parameters'>
<tr class='param'><td class='param'>data: <a href='Array.html'>Array</a> </td><td>Data to write.</td></tr></table></dd>
</dl><dl><dt>Events</dt>
<dd><table class='parameters' title='events'>
<td class='param'>readable</td><td>Issued when data is written and a consumer can read without blocking.</td></tr>
<td class='param'>writable</td><td>Issued when the stream becomes empty and it is ready to be written to.</td></tr>
</table></dd>
</dl><dl><dt>Returns</dt>
<dd>A count of the bytes actually written.</dd></dl>
<dl><dt>Throws</dt><dd>
<a href='IOError.html'>IOError</a>: if there is an I/O error.
</dd>
</dl></div>
</div>
<hr />
<div class="terms">
   <p class="terms">
       <a href="https://www.embedthis.com/">       Embedthis Software LLC, 2003-2014. All rights reserved. Embedthis is a trademark of Embedthis Software LLC.</a>
   </p>
</div></div>
</div>
</body>
</html>
